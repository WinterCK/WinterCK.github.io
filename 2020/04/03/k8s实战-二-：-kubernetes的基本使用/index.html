<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>k8s实战(二)： kubernetes的基本使用 | ChenJK Blog</title><meta name="description" content="k8s实战(二)： kubernetes的基本使用"><meta name="keywords" content="k8s"><meta name="author" content="Chen JK"><meta name="copyright" content="Chen JK"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://winterck.github.io/2020/04/03/k8s%E5%AE%9E%E6%88%98-%E4%BA%8C-%EF%BC%9A-kubernetes%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="k8s实战(二)： kubernetes的基本使用"><meta name="twitter:description" content="k8s实战(二)： kubernetes的基本使用"><meta name="twitter:image" content="http://bucket-542397.oss-cn-hangzhou.aliyuncs.com/avatar/avatar_1.jpg"><meta property="og:type" content="article"><meta property="og:title" content="k8s实战(二)： kubernetes的基本使用"><meta property="og:url" content="https://winterck.github.io/2020/04/03/k8s%E5%AE%9E%E6%88%98-%E4%BA%8C-%EF%BC%9A-kubernetes%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"><meta property="og:site_name" content="ChenJK Blog"><meta property="og:description" content="k8s实战(二)： kubernetes的基本使用"><meta property="og:image" content="http://bucket-542397.oss-cn-hangzhou.aliyuncs.com/avatar/avatar_1.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="k8s实战(一)： mac安装kubernetes的minikube" href="https://winterck.github.io/2020/04/02/k8s%E5%AE%9E%E6%88%98-%E4%B8%80-%EF%BC%9A-mac%E5%AE%89%E8%A3%85kubernetes%E7%9A%84minikube/"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://billts.site/extra_css/gitment.css"><script src="https://billts.site/js/gitment.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://jerryc.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-部分"><span class="toc-number">1.</span> <span class="toc-text">Docker 部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建一个简单的Node-js应用"><span class="toc-number">1.1.</span> <span class="toc-text">创建一个简单的Node.js应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建app-js-和Dockerfile"><span class="toc-number">1.1.1.</span> <span class="toc-text">创建app.js 和Dockerfile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构建容器镜像"><span class="toc-number">1.1.2.</span> <span class="toc-text">构建容器镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#镜像是如何构建的"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">镜像是如何构建的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#镜像分层"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">镜像分层</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行容器镜像"><span class="toc-number">1.1.3.</span> <span class="toc-text">运行容器镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#列出容器"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">列出容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取更多容器信息"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">获取更多容器信息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#探索容器内部"><span class="toc-number">1.1.4.</span> <span class="toc-text">探索容器内部</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#已有容器内部运行shell"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">已有容器内部运行shell</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#容器内的进程运行在主机操作系统上"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">容器内的进程运行在主机操作系统上</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#容器文件系统也是独立的"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">容器文件系统也是独立的</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#停止和删除容器"><span class="toc-number">1.1.5.</span> <span class="toc-text">停止和删除容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向镜像仓库推送镜像"><span class="toc-number">1.1.6.</span> <span class="toc-text">向镜像仓库推送镜像</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes部分"><span class="toc-number">2.</span> <span class="toc-text">Kubernetes部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#部署Node-js应用"><span class="toc-number">2.1.</span> <span class="toc-text">部署Node.js应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#列出Pod"><span class="toc-number">2.1.1.</span> <span class="toc-text">列出Pod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pod介绍"><span class="toc-number">2.1.2.</span> <span class="toc-text">Pod介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#幕后发生的事情"><span class="toc-number">2.1.3.</span> <span class="toc-text">幕后发生的事情</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问Web应用"><span class="toc-number">2.2.</span> <span class="toc-text">访问Web应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建一个服务对象"><span class="toc-number">2.2.1.</span> <span class="toc-text">创建一个服务对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#列出服务"><span class="toc-number">2.2.2.</span> <span class="toc-text">列出服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pod和它的容器"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">pod和它的容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ReplicationController的角色"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">ReplicationController的角色</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么需要服务"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">为什么需要服务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#水平伸缩应用"><span class="toc-number">2.3.</span> <span class="toc-text">水平伸缩应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#增加期望副本数"><span class="toc-number">2.3.1.</span> <span class="toc-text">增加期望副本数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#curl测试请求"><span class="toc-number">2.3.2.</span> <span class="toc-text">curl测试请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看应用运行在哪个节点上"><span class="toc-number">2.4.</span> <span class="toc-text">查看应用运行在哪个节点上</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#列出pod时显示pod-IP和pod的节点"><span class="toc-number">2.4.1.</span> <span class="toc-text">列出pod时显示pod IP和pod的节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/back_2.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">ChenJK Blog</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="http://bucket-542397.oss-cn-hangzhou.aliyuncs.com/avatar/avatar_1.jpg" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description">一个关于Java/Linux/数据库/缓存等等技术相关的博客</div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">k8s实战(二)： kubernetes的基本使用</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-04-03<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-04-03</time></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>​    本系列为一个k8s的实战教程系列，主要是看<strong>Kubernetes in Action</strong>这本书总结整理而来。这一篇为基础实战篇，从构建一个Docker的容器开始，再到k8s运行pod并暴露服务，还有水平伸缩应用的实战。</p>
<h2 id="Docker-部分"><a href="#Docker-部分" class="headerlink" title="Docker 部分"></a>Docker 部分</h2><h3 id="创建一个简单的Node-js应用"><a href="#创建一个简单的Node-js应用" class="headerlink" title="创建一个简单的Node.js应用"></a>创建一个简单的Node.js应用</h3><h4 id="创建app-js-和Dockerfile"><a href="#创建app-js-和Dockerfile" class="headerlink" title="创建app.js 和Dockerfile"></a>创建app.js 和Dockerfile</h4><p>创建一个名为<strong>app.js</strong>的文件，代码如下，在访问时会返回自己的主机名而不是宿主机名，这样在水平伸缩时可以看到http请求会切换到不同的实例上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Kubia server starting..."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received request from "</span> + request.connection.remoteAddress);</span><br><span class="line">    response.writeHead(<span class="number">200</span>);</span><br><span class="line">    response.end(<span class="string">"You've hit "</span> + os.hostname() + <span class="string">"\n"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> www = http.createServer(handler);</span><br><span class="line">www.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p>再创建<strong>Dockerfile</strong>文件，如下</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">7</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> app.js /app.js</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"app.js"</span>]</span></span><br></pre></td></tr></table></figure>

<p>From行定义了镜像的起始内容（构建所基于的基础镜像）。这个例子中使用的是node镜像的tag7版本。第二行中把app.js文件从本地文件夹添加到镜像的根目录，保持app.js这个文件名。最后一行定义了当镜像被运行时需要被执行的命令，这个例子中，命令是node app. js</p>
<h4 id="构建容器镜像"><a href="#构建容器镜像" class="headerlink" title="构建容器镜像"></a>构建容器镜像</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t kubia .</span><br></pre></td></tr></table></figure>

<p><img src="https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/k8s-2/docker-build.png" alt="docker build"></p>
<p>​    下图是镜像构建的过程。用户告诉Docker需要基于当前目录（注意命令结尾的点）构建一个叫kubia的镜像，Docker会在目录中寻找Dockerfile，然后基于其中的指令构建镜像。</p>
<p><img src="https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/k8s-2/2-1.png" alt="构建过程"></p>
<h5 id="镜像是如何构建的"><a href="#镜像是如何构建的" class="headerlink" title="镜像是如何构建的"></a>镜像是如何构建的</h5><p>​    构建过程不是由Docker客户端进行的，而是将整个目录的文件上传到Docker守护进程并在那里进行的。Docker客户端和守护进程不要求在同一台机器上。如果你在一台非Linux操作系统中使用Docker，客户端就运行在你的宿主操作系统上，但是守护进程运行在一个虚拟机内。由于构建目录中的文件都被上传到了守护进程中， 如果包含了大量的大文件而且守护进程不在本地运行， 上传过程会花费更多的时间。</p>
<p>​    <strong>提示：</strong>不要在构建目录中包含任何不需要的文件，这样会减慢构建的速度－尤其当Docker守护进程运行在一个远瑞机器的时候。</p>
<h5 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h5><p>​    镜像不是一个大的二进制块，而是由多层组成的，不同镜像可能会共享分层，这会让存储和传输变得更加高效。比如， 如果创建了多个基于相同基础镜像（比如node:7），所有组成基础镜像的分层只会被存储一次。拉取镜像时Docker会独立下载每一层。一些分层可能已经存储在机器上了，Docker只会下载未被存储的分层。Dockerfile中每一条单独的指令都会创建一个新层。</p>
<h4 id="运行容器镜像"><a href="#运行容器镜像" class="headerlink" title="运行容器镜像"></a>运行容器镜像</h4><p>可以使用<strong>docker images</strong> 列出本地的镜像。如下：</p>
<table>
<thead>
<tr>
<th>REPOSITORY</th>
<th>TAG</th>
<th>IMAGE ID</th>
<th>CREATED</th>
<th>SIZE</th>
</tr>
</thead>
<tbody><tr>
<td>kubia</td>
<td>latest</td>
<td>65fa98888038</td>
<td>10 minutes ago</td>
<td>660MB</td>
</tr>
</tbody></table>
<p>运行镜像</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> --name kubia-container -p:8080:8080 -d kubia</span></span><br></pre></td></tr></table></figure>

<p>然后可以使用curl来访问测试：<code>curl localhost:8080</code></p>
<p>​    docker run这条命令告知Docker基于kubia镜像创建一个叫kubia-container的新容器。 这个容器与命令行分离(-d标志），这意味着在后台运行。本机上的8080端口会被映射到容器内的8080端口(-p8080: 8080选项），所以可以通过<a href="http://localhost:8080访间这个应用">http://localhost:8080访间这个应用</a></p>
<p><img src="https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/k8s-2/docker-run.png" alt="docker run"></p>
<h5 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h5><p>​    列出运行中的容器可以使用 <code>docker ps</code> 命令，所有的容器可以使用<code>docker ps -a</code></p>
<h5 id="获取更多容器信息"><a href="#获取更多容器信息" class="headerlink" title="获取更多容器信息"></a>获取更多容器信息</h5><p>​    docker ps 只会展示容器的大部分基础信息，使用 <code>docker inspect  ${containerName}</code> 来查看更多的信息，如<code>docker inspect kubia-container</code></p>
<h4 id="探索容器内部"><a href="#探索容器内部" class="headerlink" title="探索容器内部"></a>探索容器内部</h4><h5 id="已有容器内部运行shell"><a href="#已有容器内部运行shell" class="headerlink" title="已有容器内部运行shell"></a>已有容器内部运行shell</h5><p>镜像基于的Node.js镜像包含了bash shell, 所以可以像这样在容器内运行shell :</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it kubia-container bash</span><br></pre></td></tr></table></figure>

<p>-i 表示保持开放标准输入流，这样才能在shell中输入命令。</p>
<p>-t 表示分配一个伪TTY终端。</p>
<p><img src="https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/k8s-2/exec.png" alt=""></p>
<p>可以看到只有三个进程，宿主机上无其他进程。</p>
<h5 id="容器内的进程运行在主机操作系统上"><a href="#容器内的进程运行在主机操作系统上" class="headerlink" title="容器内的进程运行在主机操作系统上"></a>容器内的进程运行在主机操作系统上</h5><p>​    如果现在打开另一个终端，然后列出主机操作系统上的进程，连同其他的主机进程依然会发现容器内的进程。<strong>注意：</strong> 如果是Mac或者Windows系统的话需要登录到Docker守护进程运行的VM查看这些进程。 我这里就不演示了。</p>
<p><img src="https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/k8s-2/process.png" alt=""></p>
<p>​    这证明了运行在容器中的进程是运行在主机操作系统上的。同时进程的ID在容器中与主机上不同。容器使用独立的PID Linux命名空间并且有着独立的系列号，完全独立于进程树。</p>
<h5 id="容器文件系统也是独立的"><a href="#容器文件系统也是独立的" class="headerlink" title="容器文件系统也是独立的"></a>容器文件系统也是独立的</h5><p>​    正如拥有独立的进程树一样，每个容器也拥有独立的文件系统。在容器内列出根目录的内容，只会展示容器内的文件，包括镜像内的所有文件，再加上容器运行时创建的任何文件（类似日志文件）。执行<code>ls</code> 可以看到目录结果。</p>
<p>​    <strong>提示：</strong>进入容器对于调试容器内运行的应用来说是非常有用的。出错时，需要做的第一件事是查看应用运行的系统的真实状态。需要记住的是，应用不仅拥有独立的文件系统，还有进程、用户、主机名和网络接口。</p>
<h4 id="停止和删除容器"><a href="#停止和删除容器" class="headerlink" title="停止和删除容器"></a>停止和删除容器</h4><p>​    <code>docker stop kubia-container</code>来停止容器，停止之后使用<code>docker ps</code> 就看不到容器了，使用<code>docker ps -a</code>可以看到。使用<code>docker rm kubia-container</code>可以删除容器。</p>
<h4 id="向镜像仓库推送镜像"><a href="#向镜像仓库推送镜像" class="headerlink" title="向镜像仓库推送镜像"></a>向镜像仓库推送镜像</h4><p>​    目前构建的镜像只能在本机使用，为了在任何机器上都可以使用，需要把镜像推送到一个外部的镜像仓库。这里直接使用 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>镜像中心。自行注册完后会有自己的Docker Hub ID。然后推送步骤如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag kubia yourId&#x2F;kubia</span><br><span class="line">docker push yourId&#x2F;kubia</span><br></pre></td></tr></table></figure>

<p>​    先使用附加标签标注镜像，<strong>yourId 要替换为自己的Docker Hub ID</strong>，之后使用<code>docker push</code> 来推送镜像。</p>
<p>​    <strong>注意：</strong> 推送前，确保保持登陆状态，没登录的话使用 <code>docker login</code>命令和自己的ID登录。</p>
<p>​    之后在其他机器上就可以直接使用如下命令来运行镜像了：<code>docker run -p 8080:8080 -d yourId/kubia</code></p>
<h2 id="Kubernetes部分"><a href="#Kubernetes部分" class="headerlink" title="Kubernetes部分"></a>Kubernetes部分</h2><p>​    在上一篇文章中，已经安装并启动了minikube，然后再上文docker部分中确保有了node的镜像。下面开始在k8s中部署这个node应用。</p>
<h3 id="部署Node-js应用"><a href="#部署Node-js应用" class="headerlink" title="部署Node.js应用"></a>部署Node.js应用</h3><p>使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run kubia --image&#x3D;yourId&#x2F;kubia --port&#x3D;8080 --generator&#x3D;run&#x2F;v1</span><br></pre></td></tr></table></figure>

<p>​    –image=yourId/kubia显示的是指定要运行的容器镜像，–port=8080选项告诉Kubernetes应用正在监昕8080端口。最后一个标志（–generator）需要解释一下，通常并不会使用到它，它让Kubemetes创建一个ReplicationController, 而不是Deployment。</p>
<p><img src="https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/k8s-2/kubectl-run.png" alt=""></p>
<h4 id="列出Pod"><a href="#列出Pod" class="headerlink" title="列出Pod"></a>列出Pod</h4><p>​    列出pod可以使用 <code>kubectl get pods</code> 来列出，如上图所示， 目前pod还在容器创建的过程中, 还没有运行起来，等过一会再执行 READY 就会变为 1/1 ，说明已经在运行中。</p>
<h4 id="Pod介绍"><a href="#Pod介绍" class="headerlink" title="Pod介绍"></a>Pod介绍</h4><p>​    一个pod是一组紧密相关的容器，它们总是一起运行在同一个工作节点上，以及同一个Linux命名空间中。每个pod就像一个独立的逻辑机器，拥有自己的IP、主机名、进程等，运行一个独立的应用程序。应用程序可以是单个进程，运行在单个容器中，也可以是一个主应用进程或者其他支持进程，每个进程都在自己的容器中运行。一个pod的所有容器都运行在同一个逻辑机器上。</p>
<p><img src="https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/k8s-2/2-2.png" alt=""></p>
<p>如果需要查看pod更多信息，还可以使用<code>kubectl describe pod</code>命令。</p>
<h4 id="幕后发生的事情"><a href="#幕后发生的事情" class="headerlink" title="幕后发生的事情"></a>幕后发生的事情</h4><p><img src="https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/k8s-2/2-3.png" alt=""></p>
<p>​    如图， 当运行kubectl命令时，它通过向Kubemetes API服务器发送一个REST HTTP请求，在集群中创建一个新的ReplicationController对象。然后，ReplicationController创建了一个新的pod，调度器将其调度到一个工作节点上。Kubelet看到pod被调度到节点上，就告知Docker从镜像中心中拉取指定的镜像，因为本地没有该镜像。下载镜像后，Docker创建并运行容器。展示另外两个节点是为了显示上下文。它们没有在这个过程中扮演任何角色，因为pod没有调度到它们上面。</p>
<h3 id="访问Web应用"><a href="#访问Web应用" class="headerlink" title="访问Web应用"></a>访问Web应用</h3><p>​    每个pod都有自己的IP地址，但是这个地址是集群内部的，不能从集群外部访问。要让pod能够从外部访问，需要通过服务对象公开它，要创建一个特殊的LoadBalancer类型的服务。因为如果你创建一个常规服务（一个ClusterIP服务），比如pod，它也只能从集群内部访问。通过创建LoadBalancer类型的服务，将创建一个外部的负载均衡，可以通过负载均衡的公共IP访问pod。</p>
<h4 id="创建一个服务对象"><a href="#创建一个服务对象" class="headerlink" title="创建一个服务对象"></a>创建一个服务对象</h4><p>要创建服务，需要告知Kubemetes对外暴露之前创建的ReplicationController。执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose rc kubia --type&#x3D;LoadBalancer --name kubia-http</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：这里用的是replicationcontroller的缩写 rc。大多数资源类型都有这样的缩写，不用输入全名（例如，pods的缩写是po，service缩写svc等）。</p>
<h4 id="列出服务"><a href="#列出服务" class="headerlink" title="列出服务"></a>列出服务</h4><p>命令：<code>kubectl get services</code> 或者<code>kubectl get svc</code> 查看创建的服务对象。</p>
<p><img src="https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/k8s-2/2-4.png" alt=""></p>
<p>​    可以看到是外部IP显示pending中，因为Kubernetes运行的云基础设施创建负载均衡需要一段时间。负载均衡启动后，应该会显示服务的外部IP地址。</p>
<p>​    <strong>注意</strong>： minikube的话这里一直都会是pending，想要看外网ip使用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube service kubia-http</span><br></pre></td></tr></table></figure>

<p>​    这会自动打开浏览器并访问外部IP和端口，如果不想自动打开浏览器，只获取外部地址的话，可以使用命令<code>minikube service kubia-http --url</code> 来获得地址，之后自己可以使用<code>curl</code>来测试。如下图所示：</p>
<p><img src="https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/k8s-2/2-5.png" alt=""></p>
<p>​    如果仔细观察，会发现应用将pod名称作为它的主机名。如前所述，每个pod都像－个独立的机器，具有自己的IP地址和主机名。尽管应用程序运行在工作节点的操作系统中，但对应用程序来说，它似乎是在一个独立的机器上运行，而这台机器本身就是应用程序的专用机器，没有其他的进程一同运行。</p>
<h5 id="pod和它的容器"><a href="#pod和它的容器" class="headerlink" title="pod和它的容器"></a>pod和它的容器</h5><p>​    在你的系统中最重要的组件是pod。它只包含一个容器，但是通常一个pod可以包含任意数量的容器。容器内部是Node.js进程，该进程绑定到8080端口， 等待HTTP请求。pod有自己独立的私有IP地址和主机名。</p>
<h5 id="ReplicationController的角色"><a href="#ReplicationController的角色" class="headerlink" title="ReplicationController的角色"></a>ReplicationController的角色</h5><p>​    kubia ReplicationController。 它确保始终存在一个运行中的pod实例。 通常，ReplicationController用于复制pod（即创建pod的多个副本）并让它们保持运行。示例中没有指定需要多少pod副本， 所以ReplicationController创建了一个副本。 如果你的pod因为任何原因消失了，那么ReplicationController将创建一个新的pod来替换消失的pod。</p>
<h5 id="为什么需要服务"><a href="#为什么需要服务" class="headerlink" title="为什么需要服务"></a>为什么需要服务</h5><p>​    kubia-http服务。 要理解为什么需要服务，需要学习有关pod的关键细节。pod的存在是短暂的，一个pod可能会在任何时候消失，或许因为它所在节点发生故障，或许因为有人删除了pod，或者因为pod被从一个健康的节点剔除了。当其中任何一种情况发生时，如前所述，消失的pod将被Replication Controller替换为新的pod。新的pod与替换它的pod具有不同的IP地址。这就是需要服务的地方解决不断变化的pod IP地址的问题，以及在一个固定的IP和端口对上对外暴露多个pod。</p>
<p>​    当一个服务被创建时，它会得到一个静态的IP，在服务的生命周期中这个IP不会发生改变。客户端应该通过固定IP地址连接到服务，而不是直接连接pod。服务会确保其中一个pod接收连接，而不关心pod当前运行在哪里（以及它的IP地址是什么）。服务表示一组或多组提供相同服务的pod的静态地址。到达服务IP和端口的请求将被转发到属于该服务的一个容器的IP和端口。</p>
<h3 id="水平伸缩应用"><a href="#水平伸缩应用" class="headerlink" title="水平伸缩应用"></a>水平伸缩应用</h3><p>​    pod由一个ReplicationController管理。查看rc，会返回如下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get rc</span><br></pre></td></tr></table></figure>

<p>NAME    DESIRED   CURRENT   READY   AGE<br>kubia       1                 1                 1           47h</p>
<p>​    该列表显示了一个名为kubia的单个ReplicationController。DESIRED列显示了希望ReplicationController保持的pod副本数，而CURRENT列显示当前运行的pod数。 在示例中，希望pod副本为1,而现在就有一个副本正在运行。</p>
<h4 id="增加期望副本数"><a href="#增加期望副本数" class="headerlink" title="增加期望副本数"></a>增加期望副本数</h4><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale rc kubia --replicas&#x3D;3</span><br></pre></td></tr></table></figure>

<p>​    此命令会告诉Kubemetes需要确保pod始终有三个实例在运行。注意， 你没有告诉Kubernetes需要采取什么行动，也没有告诉Kubernetes增加两个pod，只设置新的期望的实例数量并让Kubemetes决定需要采取哪些操作来实现期望的状态。</p>
<p>​    这是Kubernetes最基本的原则之一。不是告诉Kubemetes应该执行什么操作，而是声明性地改变系统的期望状态，并让Kubemetes检查当前的状态是否与期望的状态一致。 在整个Kubernetes世界中都是这样的。</p>
<p>​    查看扩容的结果如下：<code>kubectl get rc</code> 和 <code>kubectl get po</code> 能看到结果</p>
<p><img src="https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/k8s-2/rc-add.png" alt=""></p>
<h4 id="curl测试请求"><a href="#curl测试请求" class="headerlink" title="curl测试请求"></a>curl测试请求</h4><p>​    结果如下，请求会随机的切换到不同的pod。当pod有多个实例时Kubernetes服务就会这样做。服务作为负载均衡挡在多个pod前面。</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>curl 192.168.99.100:32369<br/>You’ve hit kubia-tqrvc<br/> curl 192.168.99.100:32369<br/>You’ve hit kubia-q989q<br/>curl 192.168.99.100:32369<br/>You’ve hit kubia-q989q<br/> curl 192.168.99.100:32369<br/>You’ve hit kubia-rctfz</td>
</tr>
</tbody></table>
<h3 id="查看应用运行在哪个节点上"><a href="#查看应用运行在哪个节点上" class="headerlink" title="查看应用运行在哪个节点上"></a>查看应用运行在哪个节点上</h3><p>​    容器中运行的所有应用都具有相同类型的操作系统。每个pod都有自己的IP,并且可以与任何其他pod通信，不论其他pod是运行在同一个节点上，还是运行在另一个节点上。每个pod都被分配到所需的计算资源，因此这些资源是由一个节点提供还是由另一个节点提供，并没有任何区别。</p>
<h4 id="列出pod时显示pod-IP和pod的节点"><a href="#列出pod时显示pod-IP和pod的节点" class="headerlink" title="列出pod时显示pod IP和pod的节点"></a>列出pod时显示pod IP和pod的节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    本文主要是对书第二章的整理，从Docker创建应用应用开始到在k8s中部署并水平扩容应用结束。看完本博客，你应该知道：</p>
<ul>
<li>Docker创建应用并会拉取和向镜像仓库推送镜像。</li>
<li>进入运行中的容器并检查环境(docker exec )。</li>
<li>在Kubernetes中查看pod、svc、rc等操作。</li>
<li>在Kubernetes中运行pod并可以在集群外访问。</li>
<li>通过改变ReplicationController来做水平伸缩。</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Chen JK</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://winterck.github.io/2020/04/03/k8s%E5%AE%9E%E6%88%98-%E4%BA%8C-%EF%BC%9A-kubernetes%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">https://winterck.github.io/2020/04/03/k8s%E5%AE%9E%E6%88%98-%E4%BA%8C-%EF%BC%9A-kubernetes%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/k8s/">k8s    </a></div><div class="post_share"><div class="social-share" data-image="http://bucket-542397.oss-cn-hangzhou.aliyuncs.com/avatar/avatar_1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/04/02/k8s%E5%AE%9E%E6%88%98-%E4%B8%80-%EF%BC%9A-mac%E5%AE%89%E8%A3%85kubernetes%E7%9A%84minikube/"><img class="next_cover lozad" data-src="https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/xingkong.jpg,https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/back_3.jpeg,https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/page/page-de1.jpg,https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/page/page-de.jpg,https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/page/page3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>k8s实战(一)： mac安装kubernetes的minikube</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/04/02/k8s实战-一-：-mac安装kubernetes的minikube/" title="k8s实战(一)： mac安装kubernetes的minikube"><img class="relatedPosts_cover lozad" data-src="https://bucket-542397.oss-cn-hangzhou.aliyuncs.com/page/page-de1.jpg"><div class="relatedPosts_title">k8s实战(一)： mac安装kubernetes的minikube</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>Comment</span></div><div id="gitment-container"></div><script>var gitment = new Gitment({
  id: md5(decodeURI(location.pathname)),
  owner: 'WinterCK',
  repo: 'ChenjkGitment',
  oauth: {
    client_id: 'a20e1237850f7980730a',
    client_secret: 'b9debe84cb941f70baf3ce4221189ed7afffbee0'
  }
})
gitment.render('gitment-container')</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Chen JK</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.miitbeian.gov.cn" target="_blank" rel="noopener"><span>浙ICP备19026477号-1</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion">簡</a><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script></body></html>